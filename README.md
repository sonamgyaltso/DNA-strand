# DNA-strand
DNA, the carrier of genetic information in living things, has been used in criminal justice for decades. But how, exactly, does DNA profiling work? Given a sequence of DNA, how can forensic investigators identify to whom it belongs?

Well, DNA is really just a sequence of molecules called nucleotides, arranged into a particular shape (a double helix). Each nucleotide of DNA contains one of four different bases: adenine (A), cytosine (C), guanine (G), or thymine (T). Every human cell has billions of these nucleotides arranged in sequence. Some portions of this sequence (i.e. genome) are the same, or at least very similar, across almost all humans, but other portions of the sequence have a higher genetic diversity and thus vary more across the population.

One place where DNA tends to have high genetic diversity is in Short Tandem Repeats (STRs). An STR is a short sequence of DNA bases that tends to be repeated back-to-back numerous times at specific locations in DNA. The number of times any particular STR repeats varies a lot among different people. In the DNA samples below, for example, Alice has the STR AGAT repeated four times in her DNA, while Bob has the same STR repeated five times.

image2.png

Using multiple STRs, rather than just one, can improve the accuracy of DNA profiling. If the probability that two people have the same number of repeats for a single STR is 5%, and the analyst looks at 10 different STRs, then the probability that two DNA samples match purely by chance is about 1 in 1 quadrillion (assuming all STRs are independent of each other). So if two DNA samples match in the number of repeats for each of the STRs, the analyst can be pretty confident they came from the same person. CODIS, The FBI's DNA database, uses 20 different STRs as part of its DNA profiling process.  More on this later. 

Utimately, you are going to write a DNA profiling app.  The app will be able to take a dna strand and determine who the DNA belongs to (using a provided database).  We will be making some approximations to the above discussion to simplify our code writing.  And there are lots of ways you could write an app like this, but for this project you will be required to solve it using a custom DNA abstraction that we will write. 

Project Summary

For this project, you are going to design a custom abstraction for DNA (in the file, dna.h).  Unlike your last project which had a c-array under the hood, this implementation is a linked structure.  As you work through the design, you will notice that implementing an abstraction using a linked structure is very different than implementing an abstraction using a c-array.  Managing memory is different and also any updates to the implementation is very different.  You MUST draw out what you are doing when you have a linked structure.  There is absolutely no way to write this code unless you are diagramming as you go.  To test your dna abstraction class, you must write tests using the Google Test framework, which you will write in tests.cpp.  The starter code for tests.cpp sets up 10 tests cases for you, categorized by public member function.  You can add more tests or just put your assertions in each test.  You may/should have 100s of assertions (calls to EXPECT_EQ) in each of the TESTs.  Think loops.  Once you have finished testing your dna abstraction class, you can move on to the application.cpp which will implement the DNA profiling described above. 
